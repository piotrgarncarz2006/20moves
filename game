#!/bin/python3

# this file should be executed from game launcher with proper arguments shuch as current map, current character, etc.

import pygame as pg
import os, sys
from math import *
from settings.settings import *
# only for debuging remove in release
from pprint import pprint

# importing map based on cmd arguments
if sys.argv[1]== '1':
    from maps.map_1 import * # provides world, sources, bg, scale, textures
elif sys.argv[1]== '2':
    from maps.map_2 import * # provides world, sources, bg, scale, textures
elif sys.argv[1]== '3':
    from maps.map_3 import * # provides world, sources, bg, scale, textures

pg.init() # allows to use pygame methods
default_font= pg.font.SysFont(font_family, default_font_size) # default font
counter_font= pg.font.SysFont(font_family, counter_font_size) # font to be used for move counter
display= pg.display.set_mode((w, h)) # creates window
fps= 60 # fps limit, this should not be changed
clock = pg.time.Clock() # clock to limit fps
moves_left= 20 # how many moves can you make

# every event that changes something on game map located in world list. Format of event_queue: [ { (text) 'action', (text) 'target', (int) 'frames', additional arguments } ] where frames is on how many frames event will execute this values is decremented every frame by event_handler()
event_queue= []

# fills background to solid color
def draw_bg():
    display.fill(bg) # change bg color of window saved in display variable

# draws every object from world list
def draw_world():
    # world[] contains every object located on current level/map
    for el in world:
        display.blit(el['texture'], (el['pos']['x'], el['pos']['y']))

# displays how many moves left for player to make
def show_move_counter():
    counter= counter_font.render(f'{moves_left}', 1, (49, 228, 201))
    display.blit(counter, (w- 50, 20))

# renders background and objects from world list and displays text
def render():
    draw_bg()
    draw_world()
    show_move_counter()

    pg.display.flip() # shows newly rendered elements

def get_player_width():
    for e in world:
        if e['obj_class']== 'player':
            return e['texture'].get_width()

def get_player_height():
    for e in world:
        if e['obj_class']== 'player':
            return e['texture'].get_height()

def get_player_x():
    for e in world:
        if e['obj_class']== 'player':
            return e['pos']['x']

def get_player_y():
    for e in world:
        if e['obj_class']== 'player':
            return e['pos']['y']

def get_player_x_and_y():
    for e in world:
        if e['obj_class']== 'player':
            return [e['pos']['x'], e['pos']['y']]

# returns player object from world array
def get_player():
    for e in world:
        if e['obj_class']== 'player':
            return e

# moves viewport by moving world array content by value argument
def move_viewport(value):
    for e in world:
        e['pos']['x']+= value
        if e['colidable']== 1 or e['colidable']== -1:
            e['hitbox']= generate_hitbox(e['obj_class'], e['texture'], e['pos']['x'], e['pos']['y'])

# adds hitboxes to every object, should be executed only once
def add_hitboxes_to_every_obj():
    for e in world:
        if e['colidable']== 1 or e['colidable']== -1:
            e['hitbox']= generate_hitbox(e['obj_class'], e['texture'], e['pos']['x'], e['pos']['y'])

# generates hitbox for requested values
def generate_hitbox(obj_class, obj_texture, x, y):
    global_rule= hitbox_generation_rules[0]
    width, height= obj_texture.get_width(), obj_texture.get_height()

    for rule_index in range(1, len(hitbox_generation_rules)):
        if hitbox_generation_rules[rule_index]['obj_class']== obj_class:
            global_rule= hitbox_generation_rules[rule_index]

    return {
            'y_top': eval(global_rule['change']['y_top']),
            'y_bot': eval(global_rule['change']['y_bot']),
            'x_left': eval(global_rule['change']['x_left']),
            'x_right': eval(global_rule['change']['x_right']),
            }

# move object from world list
def move(obj_class, speed_x, speed_y):
    for e in world:
        if e['obj_class']== obj_class:
            e['pos']['x']+= speed_x
            e['pos']['y']+= speed_y
            if e['colidable']:
                if speed_y== 0 and speed_x> 0:
                    colid_element= check_all_collisions_with_obj(e, ['x_right'])
                    if colid_element!= None:
                        e['pos']['x']= colid_element['hitbox']['x_left']- e['texture'].get_width()
                # TODO: add other conditions
            if e['colidable']== 1 or e['colidable']== -1:
                e['hitbox']= generate_hitbox(e['obj_class'], e['texture'], e['pos']['x'], e['pos']['y'])

def check_all_collisions_with_obj(obj, types):
    for e in world:
        if e!= obj:
            if check_collision(obj, e, types):
                return e

# checks collision between two objects if collision occurs returns 1 else returns 0
# types= ['y_top', 'y_bot', 'x_left', 'x_right'] for checking collisions in every direction from obj_one
def check_collision(obj_one, obj_two, types):
    obj_one_hitbox= obj_one['hitbox']
    obj_two_hitbox= obj_two['hitbox']
    if 'x_right' in types:
        obj_one_right= obj_one_hitbox['x_right']
        obj_one_top= obj_one_hitbox['y_top']
        obj_one_bot= obj_one_hitbox['y_bot']

        obj_two_left= obj_two_hitbox['x_left']
        obj_two_right= obj_two_hitbox['x_right']
        obj_two_top= obj_two_hitbox['y_top']
        obj_two_bot= obj_two_hitbox['y_bot']

        b_x_collision= obj_one_right>= obj_two_left and obj_one_right< obj_two_right
        b_y_collision= obj_one_top<= obj_two_bot and obj_one_bot>= obj_two_top

        if b_x_collision and b_y_collision:
            return True
    if 'x_left' in types:
        pass
    if 'y_top' in types:
        pass
    if 'y_bot' in types:
        pass
    return False

# check if distance from player to screen border is lesser than minimum_distance_from_border and moves viewport if true
def check_distance_from_screen_border():
    player_x= get_player_x()
    distance_from_left_border= player_x
    distance_from_right_border= w- (player_x+ get_player_width())

    if distance_from_left_border<= minimum_distance_from_border:
        move_viewport(viewport_movement_value)
    if distance_from_right_border<= minimum_distance_from_border:
        move_viewport(-viewport_movement_value)

# executes single event from event_queue
def exec_event(ev):
    if ev['action']== 'mv':
        move(ev['target'], ev['x'], ev['y'])

# handles/executes events from event_queue
def event_handler():
    delete_marks= []
    for ev in event_queue:
        ev['frames']-= 1
        exec_event(ev)
        if ev['frames']<= 0:
            delete_marks.append(ev)
    for ev in delete_marks:
        event_queue.remove(ev)

# check if key has been pressed and exec its action
def check_keys():
    # loop through pygame events such as keyboard events
    # put key shortcuts in this loop
    for event in pg.event.get():
        if event.type== pg.QUIT: sys.exit()
        if event.type== pg.KEYDOWN:
            if event.key== pg.K_d:
                # i have no idea why this globals() is necessary but if you remove it game will crash
                globals()['moves_left']-= 1
                event_queue.append({'action': 'mv', 'target': 'player', 'frames': 20, 'x': player_speed, 'y': 0})
            if event.key== pg.K_a:
                globals()['moves_left']-= 1
                event_queue.append({'action': 'mv', 'target': 'player', 'frames': 20, 'x': -player_speed, 'y': 0})

# executes before render function
def prerender():
    check_keys() # check if some binded key has been pressed and do some action/event
    event_handler() # executes events from event_queue
    check_distance_from_screen_border() # check if player's distance to border is lesser than minimum_distance_from_border and if that is true moves viewport by moving world's content

# check if player still have some moves left
def check_if_player_lost_because_of_moves_count():
    b_player_event_in_queue= False
    # check if player movement still can change because of events from event_queue with target= 'player'
    for ev in event_queue:
        if ev['target']== 'player':
            b_player_event_in_queue= True

    if moves_left<= 0 and b_player_event_in_queue is False: return True
    else: return False

if __name__== '__main__':
    add_hitboxes_to_every_obj()
    # game loop
    while True:
        clock.tick(fps) # limits fps to value of fps variable
        prerender() # handling hotkeys, event_queue, etc.
        render() # draws objects and background

        # check if player lost the game
        if check_if_player_lost_because_of_moves_count():
            sys.exit()
